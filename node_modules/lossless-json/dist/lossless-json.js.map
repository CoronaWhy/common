{"version":3,"file":"lossless-json.js","sources":["../lib/config.js","../lib/LosslessNumber.js","../lib/revive.js","../lib/pointer.js","../lib/parse.js","../lib/stringify.js"],"sourcesContent":["\nlet circularRefs = true;\n\n/**\n * Get and/or set configuration options\n * @param {{circularRefs: boolean}} [options]\n * @retrun {{circularRefs: boolean}}\n */\nexport function config (options) {\n  if (options) {\n    if (options.circularRefs !== undefined && options.circularRefs !== null) {\n      circularRefs = (options.circularRefs === true);\n    }\n  }\n\n  return { circularRefs }\n}\n","'use strict';\n\n/**\n * A lossless number. Stores it's value as string\n * @param {string | number} value\n * @constructor\n */\nexport class LosslessNumber {\n  constructor (value) {\n    // value as string\n    this.value = valueToString(value);\n\n    // type information\n    this.type = 'LosslessNumber';\n    this.isLosslessNumber = true;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number.\n   * Will throw an error when this conversion would result in a truncation\n   * of the number.\n   * @return {Number}\n   */\n  valueOf () {\n    let number = parseFloat(this.value);\n    let digits = getDigits(this.value);\n\n    // throw an error when the numeric value will lose information\n    if (digits.length > 15) {\n      throw new Error('Cannot convert to number: ' +\n          'number would be truncated (value: ' + this.value + ')');\n    }\n    if (!isFinite(number)) {\n      throw new Error('Cannot convert to number: number would overflow (value: ' + this.value + ')');\n    }\n    if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n      throw new Error('Cannot convert to number: number would underflow (value: ' + this.value + ')');\n    }\n\n    return number;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   * @return {string}\n   */\n  toString() {\n    return this.value;\n  }\n\n}\n\n/**\n * Convert input value to a string\n * If value is no number or string, the valueOf() of the object will be used.\n * @param {number | string} value\n * @return {string}\n */\nexport function valueToString (value) {\n  if (typeof value === 'string') {\n    if (!isValidNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value +'\")');\n    }\n\n    return value;\n  }\n  else if (typeof value === 'number') {\n    // validate number\n    if (getDigits(value + '').length > 15) {\n      throw new Error('Invalid number: contains more than 15 digits (value: ' + value + ')');\n    }\n    if (isNaN(value)) {\n      throw new Error('Invalid number: NaN');\n    }\n    if (!isFinite(value)) {\n      throw new Error('Invalid number: Infinity');\n    }\n\n    return value + '';\n  }\n  else {\n    return valueToString(value && value.valueOf());\n  }\n}\n\n/**\n * Parse a string into a number. When the value can be represented in a number,\n * the function returns a number. Else, the function returns a LosslessNumber\n * @param {string} value\n * @returns {LosslessNumber | number} Returns a number when the value fits\n *                                    in a regular number, else returns a\n *                                    LosslessNumber.\n */\nexport function createNumber (value) {\n  let digits = getDigits(value);\n\n  if (digits.length > 15) {\n    // would truncate digits\n    return new LosslessNumber(value);\n  }\n\n  let number = parseFloat(value);\n  if (!isFinite(number)) {\n    // overflow, finite or NaN\n    return new LosslessNumber(value);\n  }\n  else if (Math.abs(number) < Number.MIN_VALUE && !containsOnlyZeros(digits)) {\n    // underflow\n    return new LosslessNumber(value);\n  }\n  else {\n    return number;\n  }\n}\n\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.0034' returns '34'\n *   '120.5e+30' returns '1205'\n *\n * @param {number | string} value\n * @return {string} Returns the significant digits\n */\nexport function getDigits (value) {\n  let _value = (typeof value !== 'string') ? (value + '') : value;\n\n  return _value\n      .replace(/^-/, '')            // remove sign\n      .replace(/e.*$/, '')          // remove exponential notation\n      .replace( /^0\\.?0*|\\./, '');  // remove decimal point and leading zeros\n}\n\n/**\n * Test whether a string contains only zeros or is empty\n * @param {string} text\n * @return {boolean}\n */\nexport function containsOnlyZeros (text) {\n  return /^0*$/.test(text);\n}\n\n/**\n * Test whether a string contains a valid number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n * @param {string} value\n * @return {boolean}\n */\nexport function isValidNumber(value) {\n  return /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/.test(value);\n}\n","/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param {*} json   A JSON Object, Array, or value\n * @param {function (key: string, value: *)} reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n * @return {*}\n */\nexport function revive (json, reviver) {\n  return reviveValue({'': json}, '', json, reviver);\n}\n\n/**\n * Revive a value\n * @param {Object | Array} context\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *)} reviver\n * @return {*}\n */\nfunction reviveValue (context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  }\n  else if (value && typeof value === 'object' && !value.isLosslessNumber) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver))\n  }\n  else {\n    return reviver.call(context, key, value)\n  }\n}\n\n/**\n * Revive the properties of an object\n * @param {Object} object\n * @param {function} reviver\n * @return {Object}\n */\nfunction reviveObject (object, reviver) {\n  let revived = {};\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      revived[key] = reviveValue(object, key, object[key], reviver);\n    }\n  }\n\n  return revived;\n}\n\n/**\n * Revive the properties of an Array\n * @param {Array} array\n * @param {function} reviver\n * @return {Array}\n */\nfunction reviveArray (array, reviver) {\n  let revived = [];\n\n  for (let i = 0; i < array.length; i++) {\n    revived[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n\n  return revived;\n}\n","// JavaScript Object Notation (JSON) Pointer\n// https://tools.ietf.org/html/rfc6901\n\n/**\n * Escape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function escape (str) {\n  return encodeURIComponent(str\n      .replace(/\\//g, '~1')\n      .replace(/~/g, '~0'));\n}\n\n/**\n * Unescape a JSON Pointer\n *\n * @param {string} str\n * @returns {string}\n */\nexport function unescape (str) {\n  return decodeURIComponent(str)\n      .replace(/~1/g, '/')\n      .replace(/~0/g, '~');\n}\n\n/**\n * Stringify an array of keys as a JSON Pointer URI fragment\n *\n * Example:\n *\n *     stringify(['foo', 'bar'])     // returns '#/foo/bar'\n *     stringify(['foo bar', 'baz']) // returns '#/foo%20bar/baz'\n *\n * @param {Array.<string>} array\n * @returns {string}\n */\nexport function stringify(array) {\n  return '#/' + array.map(escape).join('/');\n}\n\n/**\n * Parse a JSON Pointer URI fragment\n * @param {string} pointer\n * @return {Array.<string>}\n */\nexport function parse(pointer) {\n  let array = pointer.split('/').map(unescape);\n\n  // remove the hash\n  let hash = array.shift();\n  if (hash !== '#') {\n    throw SyntaxError('Cannot parse JSON Pointer: no valid URI fragment');\n  }\n\n  // remove last empty entry\n  if (array[array.length - 1] === '') {\n    array.pop();\n  }\n\n  return array;\n}\n","'use strict';\n\nimport { config } from './config';\nimport { LosslessNumber } from './LosslessNumber';\nimport { revive } from './revive';\nimport { parse as parsePointer } from './pointer';\n\n// token types enumeration\nconst TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  NUMBER: 2,\n  STRING: 3,\n  SYMBOL: 4,\n  UNKNOWN: 5\n};\n\n// map with all delimiters\nconst DELIMITERS = {\n  '': true,\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ':': true,\n  ',': true\n};\n\n// map with all escape characters\nconst ESCAPE_CHARACTERS = {\n  '\\\"': '\\\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t'\n  // \\u is handled by getToken()\n};\n\nlet jsonText = '';                // current json text\nlet index = 0;                    // current index in text\nlet c = '';                       // current token character in text\nlet token = '';                   // current token\nlet tokenType = TOKENTYPE.NULL;   // type of current token\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * @param {string} text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param {function(key: string, value: *)} [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse (text, reviver) {\n  // initialize\n  jsonText = text;\n  index = 0;\n  c = jsonText.charAt(0);\n  token = '';\n  tokenType = TOKENTYPE.NULL;\n\n  // clear stack\n  stack = [];\n  path = [];\n\n  // get first token\n  getToken();\n\n  // parse everything\n  let json = parseObject();\n\n  if (token !== '') {\n    throw createSyntaxError('Unexpected characters');\n  }\n\n  return reviver ? revive(json, reviver) : json;\n}\n\n/**\n * Get the next character from the expression.\n * The character is stored into the char c. If the end of the expression is\n * reached, the function puts an empty string in c.\n * @private\n */\nfunction next() {\n  index++;\n  c = jsonText.charAt(index);\n}\n\n/**\n * Get next token in the current text.\n * The token and token type are available as token and tokenType\n * @private\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = '';\n\n  // skip over whitespaces: space, tab, newline, and carriage return\n  while (c === ' ' || c === '\\t' || c === '\\n' || c === '\\r') {\n    next();\n  }\n\n  // check for delimiters\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for a number\n  if (isDigit(c) || c === '-') {\n    tokenType = TOKENTYPE.NUMBER;\n\n    if (c === '-') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n    }\n    else if (c === '0') {\n      token += c;\n      next();\n    }\n    else {\n      // digit 1-9, nothing extra to do\n    }\n\n    while (isDigit(c)) {\n      token += c;\n      next();\n    }\n\n    if (c === '.') {\n      token += c;\n      next();\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    if (c === 'e' || c === 'E') {\n      token += c;\n      next();\n\n      if (c === '+' || c === '-') {\n        token += c;\n        next();\n      }\n\n      if (!isDigit(c)) {\n        throw createSyntaxError('Invalid number, digit expected', index);\n      }\n\n      while (isDigit(c)) {\n        token += c;\n        next();\n      }\n    }\n\n    return;\n  }\n\n  // check for a string\n  if (c === '\"') {\n    tokenType = TOKENTYPE.STRING;\n    next();\n\n    while (c !== '' && c !== '\"') {\n\n      if (c === '\\\\') {\n        // handle escape characters\n        next();\n\n        let unescaped = ESCAPE_CHARACTERS[c];\n        if (unescaped !== undefined) {\n          token += unescaped;\n          next();\n        }\n        else if (c === 'u') {\n          // parse escaped unicode character, like '\\\\u260E'\n          next();\n\n          let hex = '';\n          for (let u = 0; u < 4; u++) {\n            if (!isHex(c)) {\n              throw createSyntaxError('Invalid unicode character');\n            }\n            hex += c;\n            next();\n          }\n\n          token += String.fromCharCode(parseInt(hex, 16));\n        }\n        else {\n          throw createSyntaxError('Invalid escape character \"\\\\' + c + '\"', index);\n        }\n      }\n      else {\n        // a regular character\n        token += c;\n        next();\n      }\n    }\n\n    if (c !== '\"') {\n      throw createSyntaxError('End of string expected');\n    }\n    next();\n\n    return;\n  }\n\n  // check for symbols (true, false, null)\n  if (isAlpha(c)) {\n    tokenType = TOKENTYPE.SYMBOL;\n\n    while (isAlpha(c)) {\n      token += c;\n      next();\n    }\n\n    return;\n  }\n\n  // something unknown is found, wrong characters -> a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c !== '') {\n    token += c;\n    next();\n  }\n  throw createSyntaxError('Syntax error in part \"' + token + '\"');\n}\n\n/**\n * Check if the given character contains an alpha character, a-z, A-Z, _\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isAlpha (c) {\n  return /^[a-zA-Z_]/.test(c);\n}\n\n/**\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\n * @param {string} c   a string with one character\n * @return {boolean}\n */\nfunction isHex (c) {\n  return /^[0-9a-fA-F]/.test(c);\n}\n\n/**\n * checks if the given char c is a digit\n * @param {string} c   a string with one character\n * @return {boolean}\n * @private\n */\nfunction isDigit (c) {\n  return (c >= '0' && c <= '9');\n}\n\n/**\n * Create an error\n * @param {string} message\n * @param {number} [c]  Optional index (character position) where the\n *                      error happened. If not provided, the start of\n *                      the current token is taken\n * @return {SyntaxError} instantiated error\n * @private\n */\nfunction createSyntaxError (message, c) {\n  if (c === undefined) {\n    c = index - token.length;\n  }\n  let error = new SyntaxError(message + ' (char ' + c + ')');\n  error['char'] = c;\n\n  return error;\n}\n\n/**\n * Parse an object like '{\"key\": \"value\"}'\n * @return {*}\n */\nfunction parseObject () {\n  if (tokenType === TOKENTYPE.DELIMITER && token === '{') {\n    getToken();\n\n    let key;\n    let object = {};\n\n    if (tokenType === TOKENTYPE.DELIMITER && token === '}') {\n      // empty object\n      getToken();\n      return object;\n    }\n\n    // add this object to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = object;\n\n    while (true) {\n      // parse key\n      if (tokenType !== TOKENTYPE.STRING) {\n        throw createSyntaxError('Object key expected');\n      }\n      key = token;\n      getToken();\n\n      // parse key/value separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ':') {\n        throw createSyntaxError('Colon expected');\n      }\n      getToken();\n\n      // parse value\n      path[stackIndex] = key;\n      object[key] = parseObject();\n\n      // parse key/value pair separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (tokenType !== TOKENTYPE.DELIMITER || token !== '}') {\n      throw createSyntaxError('Comma or end of object \"}\" expected');\n    }\n    getToken();\n\n    // check whether this is a circular reference\n    if (isCircular(object)) {\n      return parseCircular(object);\n    }\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return object;\n  }\n\n  return parseArray();\n}\n\n/**\n * Parse an object like '[\"item1\", \"item2\", ...]'\n * @return {*}\n */\nfunction parseArray () {\n  if (tokenType === TOKENTYPE.DELIMITER && token === '[') {\n    getToken();\n\n    let array = [];\n\n    if (tokenType === TOKENTYPE.DELIMITER && token === ']') {\n      // empty array\n      getToken();\n      return array;\n    }\n\n    // add this array to the stack\n    const stackIndex = stack.length;\n    stack[stackIndex] = array;\n\n    while (true) {\n      // parse item\n      path[stackIndex] = array.length + '';\n      array.push(parseObject());\n\n      // parse item separator\n      if (tokenType !== TOKENTYPE.DELIMITER || token !== ',') {\n        break;\n      }\n      getToken();\n    }\n\n    if (tokenType !== TOKENTYPE.DELIMITER || token !== ']') {\n      throw createSyntaxError('Comma or end of array \"]\" expected');\n    }\n    getToken();\n\n    // remove current entry from the stack\n    stack.length = stackIndex;\n    path.length = stackIndex;\n\n    return array;\n  }\n\n  return parseString();\n}\n\n/**\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n * @return {*}\n */\nfunction parseString () {\n  if (tokenType === TOKENTYPE.STRING) {\n    let str = token;\n    getToken();\n    return str;\n  }\n\n  return parseNumber();\n}\n\n/**\n * Parse a number. The number will be parsed as a LosslessNumber.\n * @return {*}\n */\nfunction parseNumber () {\n  if (tokenType === TOKENTYPE.NUMBER) {\n    let number = new LosslessNumber(token);\n    getToken();\n    return number;\n  }\n\n  return parseSymbol();\n}\n\n/**\n * Parse constants true, false, null\n * @return {boolean | null}\n */\nfunction parseSymbol () {\n  if (tokenType === TOKENTYPE.SYMBOL) {\n    if (token === 'true') {\n      getToken();\n      return true;\n    }\n    if (token === 'false') {\n      getToken();\n      return false;\n    }\n    if (token === 'null') {\n      getToken();\n      return null;\n    }\n\n    throw createSyntaxError('Unknown symbol \"' + token + '\"');\n  }\n\n  return parseEnd();\n}\n\n/**\n * Evaluated when the expression is not yet ended but expected to end\n */\nfunction parseEnd () {\n  if (token === '') {\n    // syntax error or unexpected end of expression\n    throw createSyntaxError('Unexpected end of json string');\n  } else {\n    throw createSyntaxError('Value expected');\n  }\n}\n\n/**\n * Test whether an object is a circular reference, like {$ref: '#/foo/bar'}\n * @param {Object} object\n * @return {boolean}\n */\nfunction isCircular (object) {\n  return typeof object.$ref === 'string' && Object.keys(object).length === 1;\n}\n\n/**\n * Resolve a circular reference.\n * Throws an error if the path cannot be resolved\n * @param {Object} object    An object with a JSON Pointer URI fragment\n *                           like {$ref: '#/foo/bar'}\n * @return {Object | Array}\n */\nfunction parseCircular(object) {\n  // if circular references are disabled, just return the refs object\n  if (!config().circularRefs) {\n    return object;\n  }\n\n  let pointerPath = parsePointer(object.$ref);\n\n  // validate whether the path corresponds with current stack\n  for (let i = 0; i < pointerPath.length; i++) {\n    if (pointerPath[i] !== path[i]) {\n      throw new Error('Invalid circular reference \"' +  object.$ref + '\"');\n    }\n  }\n\n  return stack[pointerPath.length];\n}\n","'use strict';\n\nimport { config } from './config'\nimport { stringify as stringifyPointer } from './pointer';\n\n// Keep track of the stack to handle circular references\n// https://github.com/manuelstofer/json-pointer/blob/master/index.js\n// stack of currently stringified objects\nlet path = [];  // keys on the current stack\nlet stack = []; // objects (Object or Array) on the current stack\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param {*} value\n * The value to convert to a JSON string.\n *\n * @param {function(key: string, value: *) | Array.<string | number>} [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param {number | string} [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @returns {string | undefined} Returns the string representation of the JSON object.\n */\nexport function stringify(value, replacer, space) {\n  // clear stack\n  stack = [];\n  path = [];\n\n  let _value = (typeof replacer === 'function')\n      ? replacer.call({'': value}, '', value)\n      : value;\n\n  let _space; // undefined by default\n  if (typeof space === 'number') {\n    if (space > 10) {\n      _space = repeat(' ', 10);\n    }\n    else if (space >= 1) {\n      _space = repeat(' ', space);\n    }\n    // else ignore\n  }\n  else if (typeof space === 'string' && space !== '') {\n    _space = space;\n  }\n\n  return stringifyValue(_value, replacer, _space, '');\n}\n\n/**\n * Stringify a value\n * @param {*} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string | undefined}\n */\nfunction stringifyValue(value, replacer, space, indent) {\n  // boolean, null, number, string, or date\n  if (typeof value === 'boolean' || value instanceof Boolean ||\n      value === null ||\n      typeof value === 'number' || value instanceof Number ||\n      typeof value === 'string' || value instanceof String ||\n      value instanceof Date) {\n    return JSON.stringify(value);\n  }\n\n  // lossless number, the secret ingredient :)\n  if (value && value.isLosslessNumber) {\n    return value.value;\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return stringifyArray(value, replacer, space, indent);\n  }\n\n  // object (test lastly!)\n  if (value && typeof value === 'object') {\n    return stringifyObject(value, replacer, space, indent);\n  }\n\n  return undefined;\n}\n\n/**\n * Stringify an array\n * @param {Array} array\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyArray(array, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let str = space ? '[\\n' : '[';\n\n  // check for circular reference\n  if (isCircular(array)) {\n    return stringifyCircular(array, replacer, space, indent);\n  }\n\n  // add this array to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = array;\n\n  for (let i = 0; i < array.length; i++) {\n    let key = i + '';\n    let item = (typeof replacer === 'function')\n        ? replacer.call(array, key, array[i])\n        : array[i];\n\n    if (space) {\n      str += childIndent;\n    }\n\n    if (typeof item !== 'undefined' && typeof item !== 'function') {\n      path[stackIndex] = key;\n      str += stringifyValue(item, replacer, space, childIndent);\n    }\n    else {\n      str += 'null'\n    }\n\n    if (i < array.length - 1) {\n      str += space ? ',\\n' : ',';\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + ']') : ']';\n  return str;\n}\n\n/**\n * Stringify an object\n * @param {Object} object\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyObject(object, replacer, space, indent) {\n  let childIndent = space ? (indent + space) : undefined;\n  let first = true;\n  let str = space ? '{\\n' : '{';\n\n  if (typeof object.toJSON === 'function') {\n    return stringify(object.toJSON(), replacer, space);\n  }\n\n  // check for circular reference\n  if (isCircular(object)) {\n    return stringifyCircular(object, replacer, space, indent);\n  }\n\n  // add this object to the stack\n  const stackIndex = stack.length;\n  stack[stackIndex] = object;\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      let value = (typeof replacer === 'function')\n          ? replacer.call(object, key, object[key])\n          : object[key];\n\n      if (includeProperty(key, value, replacer)) {\n        if (first) {\n          first = false;\n        }\n        else {\n          str += space ? ',\\n' : ',';\n        }\n\n        str += space\n            ? (childIndent + '\"' + key + '\": ')\n            : ('\"' + key + '\":');\n\n        path[stackIndex] = key;\n        str += stringifyValue(value, replacer, space, childIndent);\n      }\n    }\n  }\n\n  // remove current entry from the stack\n  stack.length = stackIndex;\n  path.length = stackIndex;\n\n  str += space ? ('\\n' + indent + '}') : '}';\n  return str;\n}\n\n/**\n * Test whether an object or array is a circular reference\n * @param {Object | Array} value\n * @return {boolean}\n */\nfunction isCircular(value) {\n  return stack.indexOf(value) !== -1;\n}\n\n/**\n * Stringify a circular reference\n * @param {Object | Array} value\n * @param {function | Array.<string | number>} [replacer]\n * @param {string} [space]\n * @param {string} [indent]\n * @return {string}\n */\nfunction stringifyCircular (value, replacer, space, indent) {\n  if (!config().circularRefs) {\n    throw new Error('Circular reference at \"' + stringifyPointer(path) + '\"');\n  }\n\n  let pathIndex = stack.indexOf(value);\n\n  let circular = {\n    $ref: stringifyPointer(path.slice(0, pathIndex))\n  };\n\n  return stringifyObject(circular, replacer, space, indent);\n}\n\n/**\n * Test whether to include a property in a stringified object or not.\n * @param {string} key\n * @param {*} value\n * @param {function(key: string, value: *) | Array<string | number>} [replacer]\n * @return {boolean}\n */\nfunction includeProperty (key, value, replacer) {\n  return typeof value !== 'undefined'\n      && typeof value !== 'function'\n      && (!Array.isArray(replacer) || contains(replacer, key));\n}\n\n/**\n * Check whether an array contains some value.\n * Uses a non-strict comparison, so contains([1,2,3], '2') returns true\n * @param {Array} array\n * @param {*} value\n * @return {boolean}\n */\nfunction contains(array, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] == value) { // non-strict equality check!\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Repeat a string a number of times.\n * Simple linear solution, we only need up to 10 iterations in practice\n * @param {string} text\n * @param {number} times\n * @return {string}\n */\nfunction repeat (text, times) {\n  let res = '';\n  while (times-- > 0) {\n    res += text;\n  }\n  return res;\n}\n"],"names":["circularRefs","config","options","undefined","LosslessNumber","value","valueToString","test","isValidNumber","Error","getDigits","length","isNaN","isFinite","valueOf","type","isLosslessNumber","number","parseFloat","this","digits","Math","abs","Number","MIN_VALUE","replace","reviveValue","context","key","reviver","Array","isArray","call","array","revived","i","reviveArray","object","hasOwnProperty","reviveObject","escape","str","encodeURIComponent","unescape","decodeURIComponent","stringify","map","join","TOKENTYPE","DELIMITERS","ESCAPE_CHARACTERS","jsonText","index","c","token","tokenType","NULL","path","stack","next","charAt","getToken","DELIMITER","isDigit","NUMBER","createSyntaxError","isAlpha","UNKNOWN","SYMBOL","STRING","unescaped","hex","u","isHex","String","fromCharCode","parseInt","message","error","SyntaxError","parseObject","stackIndex","$ref","Object","keys","isCircular","pointerPath","pointer","split","shift","pop","parsePointer","parseCircular","push","parseEnd","parseSymbol","parseNumber","parseString","parseArray","replacer","space","_value","_space","repeat","stringifyValue","indent","Boolean","Date","JSON","childIndent","stringifyCircular","item","stringifyArray","stringifyObject","first","toJSON","includeProperty","indexOf","stringifyPointer","pathIndex","slice","contains","text","times","res","json","revive"],"mappings":"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"}